<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="UTF-8">
   <meta http-equiv="X-UA-Compatible" content="IE=edge">
   <meta name="viewport" content="initial-scale=1.0">
   <link rel="stylesheet" href="style.css">
   <script src="./build/aya.js"></script>
   <title>ayajs</title>
</head>

<body>

   <script>
      var aya = new aya.Application();
      console.log(aya);

      var abscisse = [];
      var ordinate = [];
      nbr_point = 20;


      function init(){
         for(var i = 0; i < nbr_point; i++){
               abscisse[i] = Math.floor(Math.random() * (500 - 1 + 1)) + 1;
               ordinate[i] = Math.floor(Math.random() * (500 - 1 + 1)) + 1;
         }
      }

      var children = [];
      function drawPoint(){
         var child = [];
         for(var i = 0; i < nbr_point; i++){
            var pt = aya.createCircle(abscisse[i], ordinate[i], 3);
            pt.draw();

            child.push(pt);
            pt.vertex.map((vt) => {
               vt.removeFromDOM();
            });
            pt.c_points.map((c_p) => {
               c_p.removeFromDOM();
            });
            pt.c_svg.setAttribute("fill","black");
         }

         children = [...child];
      }

      function removePoint(){
         children.map( (ch) => {
            ch.removeFromDOM();
         })
      }

      function getPivotAtIndexZero(){
         var k, l;
         for(var i = nbr_point; i >= 0; i--){
            for(var j = 0; j < i; j++){
               if( ordinate[j] < ordinate[j+1]){
                  k = abscisse[j];
                  l = ordinate[j];
                  abscisse[j] = abscisse[j+1];
                  ordinate[j] = ordinate[j+1];
                  abscisse[j+1] = k;
                  ordinate[j+1] = l;
               }
            }
         }

         // if(abscisse[0] == abscisse[1]){
         //    if(ordinate[0] > ordinate[1]){
         //       k = abscisse[0];
         //       l = ordinate[0];
         //       abscisse[0] = abscisse[1];
         //       ordinate[0] = ordinate[1];
         //       abscisse[1] = k;
         //       ordinate[1] = l;
         //    }
         // }
      }

      function getSmallAngle(x_point, y_point, absciss, ordinate){
         var cvx_absciss = [...absciss];
         var cvx_ordinate = [...ordinate];
         var cos_min = -1;
         var indice = -5;
         for(var i = 0; i < cvx_absciss.length; i++){
            var scalar_product = (cvx_absciss[i] - x_point) * (cvx_absciss[i] - x_point);
            var d_ab = Math.sqrt( Math.pow(  (cvx_absciss[i] - x_point),2) );
            var d_ac = Math.sqrt( Math.pow( (cvx.absciss[i] - x_point), 2) + Math.pow( (cvx.ordinate[i] - y_point), 2) );
            var cos_ab_ac = scalar_product / ( d_ab * d_ac);
            if(cos_ab_ac > cos_min){
               cos_min = cos_ab_ac;
               indice = i;
            }
         }
         return indice;
      }

      var cv = [];
      function envelop_convexe(){
         var cvx = [];
         for(var i = 0; i < nbr_point; i++){
            if(i == 0){
               var line = aya.createLine(abscisse[i], ordinate[i], 1300, ordinate[i]);
               line.draw();
               for(var j = i+1; j< nbr_point; j++){
                  var line = aya.createLine(abscisse[i], ordinate[i], abscisse[j], ordinate[j]);
                  line.draw();
               }
               cvx.push({x: abscisse[i], y: ordinate[i]});
            }
            var indice = getSmallAngle(abscisse[i], ordinate[i], abscisse, ordinate);
            cvx.push({x: abscisse[indice], y: ordinate[i]});
         }

         cv = [...cvx];
      }

      function draw_envelop_convexe(){
         for(var i = 0; i < cv.length; cv++){
            var line = aya.createLine()
         }
      }

      init();
      getPivotAtIndexZero();
      drawPoint();
      sortByAngle();
      removePoint();
      drawPoint()
      envelop_convexe();
      document.body.append(aya.svg);
   </script>

</body>

</html>